<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Is scala code slow?</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/beige.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<style media="screen" type="text/css">
		  .reveal .slides footer {
        position:absolute;
        bottom: 1em;
        left: -10%;
				font-size: 20px;
				z-index: -1;
      }
			.reveal .highlight-line {
				opacity: 1;
				visibility: visible;
			}
			.reveal .highlight-line .visible {
				background-color: #666666;
			}
			.reveal .hljs mark {
				background-color: #666666;
			}
			header {
				position: absolute;
				background-color: black;
				width: 100%;
				color: white
			}
			footer {
				width: 100%;
				position: absolute;
				bottom: 10px;
				z-index: -1;
			}
		</style>
	</head>
	<body>
		<header>&nbsp;<img src="images/scalaio.png" height="20px"></header>
		<div class="reveal">
			<div class="slides">
				<section id="title">
					<br/>
					<img src="images/scala-slowpoke.png" class="plain" height="200px"/>
					<h1>Is scala code slow?</h1>
					<br/>
					<p>Grebennikov Roman <a href="http://twitter.com/public_void_grv"><img src="images/twitter.png" height="25px" class="plain" style="margin: 0px 0px;"/></a> <a href="http://findify.io">Findify</a></p>
					<p>scala.io / 2016</p>
				</section>
				<section>
					<h2>Disclaimer</h2>
					<p>The resemblance of any opinion, recommendation <br/>
             or comment made during this presentation to performance<br/>
						 tuning advice is merely coincidental</p>
				</section>
				<section id="intro">
					<h2>Intro: cool things in scala</h2>
					<table>
						<tr>
							<td>
								<ul>
									<li>FP style</li>
									<li>type system</li>
									<li>pattern matching</li>
								</ul>
							</td>
							<td>
								<ul>
									<li>laziness</li>
									<li>collections</li>
									<li>etc...</li>
								</ul>
							</td>
						</tr>
					</table>
				</section>
				<section>
					<h2>Intro: hot cool things</h2>
					<p>Scala &amp; code hot spots:</p>
					<ul>
						<li>More readable</li>
						<li>
							Less predictable:
							<ul>
								<li class="fragment">create new objects</li>
								<li class="fragment">do unexpected computations</li>
								<li class="fragment">surprize the JVM</li>
							</ul>
						</li>
					</ul>
				</section>
				<section id="agenda">
					<h2>Agenda</h2>
					<p>
						Basics:
						<ul>
							<li class="fragment">Performance measuring is hard</li>
							<li class="fragment">What JVM &amp; scalac do with your code</li>
							<li class="fragment">JMH &amp; how to measure <strike>wrong</strike> right</li>
						</ul>
					</p>
				</section>
				<section>
					<h2>Agenda</h2>
					<p>
						Real life:
						<ul>
							<li>Pattern matching</li>
							<li>Recursion</li>
							<li>Collections</li>
						</ul>
					</p>
				</section>
				<section id="bench-hard">
					<h2>Is benchmarking really hard?</h2>
					<pre class="fragment"><code data-trim data-noescape style="padding: 25px; font-size: 25px; line-height: 30px">
val start = System.currentTimeMillis()
for (i <- 0 to 1000) yield doSomeStuff()
val perf = (System.currentTimeMillis() - start) / 1000.0
					</code></pre>
					<ul>
						<li class="fragment">loop can be eliminated by optimizer</li>
						<li class="fragment">doSomeStuff() can be interpreted, not compiled</li>
						<li class="fragment">the whole loop may take less than 1ms</li>
						<li class="fragment">... and many more</li>
					</ul>
				</section>
				<section>
					<h2>HotSpot JVM is smart<span style="color: grey;" class="fragment">er than you</span></h2>
				</section>
				<section>
					<h2>Hit the compile button</h2>
					<img src="images/magic_1.png" class="plain" height="300px"/>
				</section>
				<section>
					<h2>Hit the compile button</h2>
					<img src="images/magic_2.png" class="plain" height="300px"/>
				</section>
				<section>
					<h2>Hit the compile button</h2>
					<img src="images/magic_3.png" class="plain" height="300px"/>
				</section>
				<section>
					<h2>Hit the compile button</h2>
					<img src="images/magic_4.png" class="plain" height="300px"/>
				</section>
				<section>
					<h2>Hit the compile button</h2>
					<img src="images/cpu_diagram.png" class="plain" height="300px"/>
				</section>
				<section>
					<h2>Hit the compile button</h2>
					<img src="images/cpu_diagram.png" class="plain" height="300px"/>
					<ul>
						<li>
							C0 &#10230; C1 &#10230; C2
							<ul>
								<li class="fragment">more agressive: code is faster</li>
								<li class="fragment">more time for warm-up</li>
							</ul>
						</li>
						<li class="fragment">Pitfalls everywhere</li>
					</ul>
				</section>
				<section>
					<h2>Need reliable result?</h2>
					<table>
						<tr>
							<td style="vertical-align: middle;">
								<p>Avoid all the traps:</p>
								<ul class="fragment">
									<li>time measurement</li>
									<li>dead code elimination</li>
									<li>constant folding</li>
									<li>loop unrolling</li>
									<li>... and many more!</li>
								</ul>
							</td>
							<td>
								<img class="fragment" src="images/reinvent_the_wheel.jpg" height="400px">
							</td>
						</tr>
					</table>
				</section>
				<section>
					<h2>Meet JMH</h2>
					<p>Harness for implementing &amp; running [micro] benchmarks.</p>
					<p class="fragment"><strong>sbt-jmh</strong> plugin for easy scala integration:</p>
					<pre class="fragment"><code data-trim data-noescape style="padding: 25px;  font-size: 25px; line-height: 30px">
package io.scala

import org.openjdk.jmh.annotations._

class Demo {
	@Benchmark
	def helloWorld = 42
}
					</code></pre>
				</section>
				<section>
					live!
				</section>
				<section>
					<h2>JVM performance testing: deep dive</h2>
					<ul>
						<li>
							Alexey Shilipev talks &amp; blog posts:
							<ul>
								<li><a href="https://shipilev.net/#performance-101">Performance methodology how-to</a></li>
								<li><a href="https://shipilev.net/#benchmarking-1">the art of Java benchmarking</a></li>
								<li><a href="https://shipilev.net/blog/2014/nanotrusting-nanotime/">Nanotrusting the nanotime</a></li>
							</ul>
						</li>
						<li><a href="http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/">JMH code samples</a></li>
					</ul>
				</section>
				<section data-background="images/carpet.jpg">
					<h2><span style="background-color: white; padding: 10px">Pattern matching</span></h2>
				</section>
				<section>
					<h2>Problem</h2>
					<pre><code data-trim data-noescape style="padding: 25px; font-size: 25px; line-height: 30px" class="scala">trait Base
class Foo extends Base
class Bar extends Base
class Baz extends Base

// which class does implement Base?
def select(value:Base) = ???</code></pre>
				</section>
				<section>
					<h2>If vs pattern matching</h2>
					<pre><code data-trim data-noescape style="padding: 5px; font-size: 25px; line-height: 30px" class="scala">@Benchmark
def measurePatMat = input match {
	case _:Foo => 1
	case _:Bar => 2
	case _:Baz => 3
	case _ => 4
}</code></pre>
					<pre><code data-trim data-noescape style="padding: 5px; font-size: 25px; line-height: 30px" class="scala">@Benchmark
def measureIf = if (input.isInstanceOf[Foo])
  1
else if (input.isInstanceOf[Bar])
  2
else if (input.isInstanceOf[Baz])
  3
else
  4</code></pre>
				</section>
				<section>
					<h2>Results</h2>
					<pre><code data=trim data-noescape style="padding: 25px; font-size: 23px; line-height: 25px" class="scala">Benchmark                   (classType)  Mode  Cnt  Score   Error  Units
ScalaTypeMatch.measureIf            foo  avgt  100  3.491 ± 0.025  ns/op
ScalaTypeMatch.measureIf            bar  avgt  100  4.065 ± 0.016  ns/op
ScalaTypeMatch.measureIf            baz  avgt  100  4.167 ± 0.022  ns/op
ScalaTypeMatch.measurePatternMatch  foo  avgt  100  3.484 ± 0.020  ns/op
ScalaTypeMatch.measurePatternMatch  bar  avgt  100  4.058 ± 0.008  ns/op
ScalaTypeMatch.measurePatternMatch  baz  avgt  100  4.168 ± 0.015  ns/op</code></pre>
				</section>
				<section>
					<h2>Results</h2>
					<pre><code data=trim data-noescape style="padding: 25px; font-size: 23px; line-height: 25px" class="scala">Benchmark                   (classType)  Mode  Cnt  Score   Error  Units
ScalaTypeMatch.measureIf            foo  avgt  100  3.491 ± 0.025  ns/op
ScalaTypeMatch.measureIf            bar  avgt  100  4.065 ± 0.016  ns/op
<mark>ScalaTypeMatch.measureIf            baz  avgt  100  4.167 ± 0.022  ns/op</mark>
ScalaTypeMatch.measurePatternMatch  foo  avgt  100  3.484 ± 0.020  ns/op
ScalaTypeMatch.measurePatternMatch  bar  avgt  100  4.058 ± 0.008  ns/op
<mark>ScalaTypeMatch.measurePatternMatch  baz  avgt  100  4.168 ± 0.015  ns/op</mark></code></pre>
					<p class="fragment">Is it really the same?</p>
				</section>
				<section>
					<h2>Machine code to the rescue</h2>
					<ul>
						<li>Shows all the truth</li>
						<li>Only the brave can read it</li>
					</ul>
					<p class="fragment"><img src="images/hackerman.jpg" height="300px"/></p>
				</section>
				<section>
					<h2>Want some x86_64?</h2>
					<ul>
						<li class="fragment">-XX:+PrintAssembly: dump all the compiled methods: <strong class="fragment">TL&amp;DR</strong></li>
						<li class="fragment">perf: Linux CPU perf counters: <strong class="fragment">too low level</strong></li>
						<li class="fragment">JMH perfasm: combines both, made for humans: <strong class="fragment" style="color: green;">OK</strong></li>
					</ul>
				</section>
				<section>
					live!
				</section>
				<section>
					<img src="images/leonidas_wtf.jpg">
					<p class="fragment">I want my scala back!</p>
				</section>
				<section>
					<h2>Inside pattern matching</h2>
					<pre><code data=trim data-noescape style="padding: 25px; font-size: 25px; line-height: 28px" class="asm"><span class="fragment highlight-current-green">mov    0x10(%r8),%r10d    ;*getfield someClass // someClass = Baz</span>
<span class="fragment highlight-current-green">mov    0x8(%r12,%r10,8),%ecx  ;*instanceof</span>
<span class="fragment highlight-current-green">cmp    $0xf8019288,%ecx   ;{metadata(&apos;ru/jugvrn/ScalaTypeMatch$Foo&apos;)}</span>
<span class="fragment highlight-current-green">je     0x00007f3e0d222734  ;*ifeq</span>
<span class="fragment highlight-current-green">cmp    $0xf8019306,%ecx   ;{metadata(&apos;ru/jugvrn/ScalaTypeMatch$Bar&apos;)}</span>
<span class="fragment highlight-current-green">je     0x00007f3e0d222761  ;*ifeq</span>
<span class="fragment highlight-current-green">cmp    $0xf8019248,%ecx   ;{metadata(&apos;ru/jugvrn/ScalaTypeMatch$Baz&apos;)}</span>
<span class="fragment highlight-current-green">jne    0x00007f3e0d22281d  ;*instanceof</span>
...
<span class="fragment highlight-current-green">callq  0x00007f3e0d046020  ; *invokevirtual consume</span></code></pre>
				</section>
				<section>
					<h2>Inside if-else</h2>
					<pre><code data=trim data-noescape style="padding: 25px; font-size: 25px; line-height: 28px" class="asm">mov    0x10(%r8),%r11d    ;*getfield someClass
mov    0x8(%r12,%r11,8),%edx  ;*instanceof
cmp    $0xf8019288,%edx   ;{metadata(&apos;ru/jugvrn/ScalaTypeMatch$Foo&apos;)}
je     0x00007faa4522ac3b  ;*ifeq
cmp    $0xf8019306,%edx   ;{metadata(&apos;ru/jugvrn/ScalaTypeMatch$Bar&apos;)}
je     0x00007faa4522ac71  ;*ifeq
cmp    $0xf8019248,%edx   ;{metadata(&apos;ru/jugvrn/ScalaTypeMatch$Baz&apos;)}
jne    0x00007faa4522ad31  ;*instanceof
...
callq  0x00007faa45046020  ; *invokevirtual consume</code></pre>
				</section>
				<section>
					<h2>Same x86_64 code!</h2>
					<p class="fragment">pattern matching ~ if-else<span class="fragment">*</span></p>
				</section>
				<section>
					<h2>What about Options?</h2>
					<pre><code data=trim data-noescape style="padding: 25px; font-size: 25px; line-height: 28px" class="scala">@Setup def setup() = {
	someString = Some("hello")
	nullableString = "hello"
}

@Benchmark def measureMatchOption() = someString match {
  case Some(str) => str
  case _ => "default value"
}

@Benchmark def measureIfNull() = if (nullableString != null)
  nullableString
else
  "default value"</code></pre>
				</section>
				<section>
					<h2>Results</h2>
					<pre><code data=trim data-noescape style="padding: 25px; font-size: 25px; line-height: 28px" class="scala">
Benchmark                            Mode  Cnt  Score   Error  Units
ScalaOptionMatch.measureIfNull       avgt  100  3.677 ± 0.035  ns/op
ScalaOptionMatch.measureMatchOption  avgt  100  4.153 ± 0.066  ns/op
  				</code></pre>
					<ul>
						<li class="fragment">Results are close, but null check is faster</li>
						<li class="fragment">Why?</li>
					</ul>
					<img class="plain" height="900px" src="images/large_slowpoke.png" style="position: absolute; right: -250px;"/>
				</section>
				<section>
					<h2>Inside nullcheck</h2>
					<pre><code data=trim data-noescape style="padding: 25px; font-size: 25px; line-height: 28px" class="asm">mov    0x10(%r10),%r11d   ;*getfield nullableString
test   %r11d,%r11d
je     0x00007fb929230422  ;*ifnull
lea    (%r12,%r11,8),%rdx  ;*getfield nullableString
...
callq  0x00007fb929046020  ;*invokevirtual consume</code></pre>
				</section>
				<section>
					<h2>Inside option matching</h2>
					<pre><code data=trim data-noescape style="padding: 25px; font-size: 25px; line-height: 28px" class="asm">mov    0xc(%r10),%r11d    ;*getfield someString
mov    0x8(%r12,%r11,8),%r8d  ; implicit exception: dispatches to ...
cmp    $0xf80191cc,%r8d   ;   {metadata(&apos;scala/Some&apos;)}
jne    0x00007f7be1233711
lea    (%r12,%r11,8),%r10  ;*instanceof
mov    0xc(%r10),%r11d    ;*getfield value
mov    0x8(%r12,%r11,8),%r10d  ; implicit exception: dispatches to ...
cmp    $0xf80002da,%r10d  ;   {metadata(&apos;java/lang/String&apos;)}
jne    0x00007f7be1233725
...
callq  0x00007f7be1046020  ;*invokevirtual consume</code></pre>
				</section>
				<section>
					<h2>What's the difference?</h2>
					<ul>
						<li>
							Null check: single branch
						</li>
						<li>
							Match by Option: TWO branches
							<ul>
								<li>Are we dealing with an Option?</li>
								<li>Is there a String inside?</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					<h2>nullcheck vs patmat: Conclusion</h2>
					<p class="fragment">Pattern matching may have overhead :(</p>
					<p class="fragment">The overhead is small :)</p>
				</section>
				<section data-background-video="images/slowmatte2.mp4" data-background-video-loop="true" style="z-index: 999">
					<h2><span style="background-color: white; padding: 10px">Tail recursion</span></h2>
				</section>
				<section>
					<h2>Tail call optimization</h2>
					<ul>
						<li class="fragment">Compiler trick: transform recursive call into a loop</li>
						<li class="fragment">scalac can do it only for <b>tail</b> calls</li>
						<li class="fragment">hotspot has no native support for TCO</li>
					</ul>
				</section>
				<section>
					<h2>Meet Fibonacci</h2>
					<img src="images/fibonacci.jpg"/>
					<p>0 1 1 2 3 5 8 13 21 ...</p>
				</section>
				<section>
					<h2>Recursion: with and without tail</h2>
					<pre><code data=trim data-noescape style="padding: 25px; font-size: 25px; line-height: 28px" class="scala">@tailrec
private def fibonacciTailRec(n: Int, a:Int, b:Int):Int = n match {
  case 0 => a
  case _ => fibonacciTailRec(n-1, b, a+b)
}</code></pre>
					<pre><code data=trim data-noescape style="padding: 25px; font-size: 25px; line-height: 28px" class="scala">def fibonacciRec(n:Int):Int = n match {
  case 0 => a
	case _ => fibonacciRec(n-1, b, a+b)
}</code></pre>
				</section>
				<section>
					<h2>Old good loop</h2>
					<pre><code data=trim data-noescape style="padding: 25px; font-size: 25px; line-height: 28px" class="scala">def fibonacciLoop(n:Int):Int = {
  var a: Int = 0
  var b: Int = 1
  var i: Int = 0
	while (i < n) {
	  val sum = a + b
	  a = b
	  b = sum
	  i += 1
	}
	a
}</code></pre>
				</section>
				<section>
					<h2>Results</h2>
					<pre><code data=trim data-noescape style="padding: 25px; font-size: 25px; line-height: 28px" class="scala">Benchmark                      (N)  Mode  Cnt   Score   Error  Units
ScalaFibonacci.measureLoop      10  avgt   10   6.510 ± 0.177  ns/op
ScalaFibonacci.measureLoop      20  avgt   10  10.431 ± 0.446  ns/op
ScalaFibonacci.measureLoop      40  avgt   10  20.051 ± 0.026  ns/op
ScalaFibonacci.measureRec       10  avgt   10  18.733 ± 0.049  ns/op
ScalaFibonacci.measureRec       20  avgt   10  35.517 ± 0.162  ns/op
ScalaFibonacci.measureRec       40  avgt   10  77.468 ± 0.774  ns/op
ScalaFibonacci.measureTailRec   10  avgt   10  12.477 ± 0.289  ns/op
ScalaFibonacci.measureTailRec   20  avgt   10   9.660 ± 0.190  ns/op
ScalaFibonacci.measureTailRec   40  avgt   10  20.165 ± 2.081  ns/op
</code></pre>
					<ul>
						<li class="fragment">measureLoop is close to measureTailRec</li>
						<li class="fragment">measureRec is 2x-4x slower than measureTailRec</li>
						<li class="fragment">measureTailRec for N=10 is slower than for N=20</li>
					</ul>
				</section>
				<section>
					<h2>Why is non-TCO function so slow?</h2>
					<img src="images/slowpoke.png" height="300px" class="plain"/>
				</section>
				<section>
					<h2>bytecode to the rescue!</h2>
					<ul>
						<li class="fragment">JVM Bytecode is simple</li>
						<li class="fragment"><b>javap</b>: a tool for class file disassembly</li>
					</ul>
					<pre class="fragment"><code data=trim data-noescape style="padding: 25px; font-size: 25px; line-height: 28px" class="shell">Welcome to Scala 2.11.8
(Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_102)
Type in expressions for evaluation. Or try :help.

scala> :javap -c -p ru.jugvrn.ScalaFibonacci
Compiled from "ScalaFibonacci.scala"
public class ru.jugvrn.ScalaFibonacci {
private int N;

...</code></pre>
				</section>
				<section>
					<h3>Fibonacci with TCO</h3>
					<pre><code data=trim data-noescape style="padding: 15px; max-height: 470px;" class="java">       0: iload_1           <span class="fragment">// Load first function argument, N</span>
       1: istore        5
       3: iload         5
       5: tableswitch   {
                     0: 37  <span class="fragment">// if N == 0, goto :37</span>
               default: 24  <span class="fragment">// else goto :24</span>
          }
      24: iload_1           <span class="fragment">// get arg1     (stack: N)</span>
      25: iconst_1          <span class="fragment">// push 1       (stack: 1, N)</span>
      26: isub              <span class="fragment">// subtract     (stack: N-1)</span>
      27: iload_3           <span class="fragment">// get arg3     (stack: b, N-1)</span>
      28: iload_2           <span class="fragment">// get arg2     (stack: a, b, N-1)</span>
      29: iload_3           <span class="fragment">// get arg3     (stack: b, a, b, N-1)</span>
      30: iadd              <span class="fragment">// add 2 vars   (stack: a+b, b, N-1)</span>
      31: istore_3          <span class="fragment">// set arg3=a+b (stack: b, N-1)</span>
      32: istore_2          <span class="fragment">// set arg2=b   (stack: N-1)</span>
      33: istore_1          <span class="fragment">// set arg1=N-1 (stack: )</span>
      34: goto          0   <span class="fragment">// jump to the function start</span>
      37: iload_2
      38: ireturn           <span class="fragment">// return arg2=b</span>
</code></pre>
				</section>
				<section>
					<h3>Fibonacci without TCO</h3>
					<pre><code data=trim data-noescape style="padding: 15px; max-height: 470px;" class="java">       0: iload_1           <span class="fragment">// Load first function argument, N</span>
       1: istore        4
       3: iload         4
       5: tableswitch   {
                     0: 38  <span class="fragment">// if N == 0, goto :38</span>
               default: 24  <span class="fragment">// else goto :24</span>
          }
      24: aload_0           <span class="fragment">// get <i>this</i> reference         (stack: this)</span>
      25: iload_1           <span class="fragment">// get arg1                   (stack: N, this)</span>
      26: iconst_1          <span class="fragment">// push 1                     (stack: 1, N, this)</span>
      27: isub              <span class="fragment">// subtract                   (stack: N-1, this)</span>
      28: iload_3           <span class="fragment">// get arg3                   (stack: b, N-1, this)</span>
      29: iload_2           <span class="fragment">// get arg2                   (stack: a, b, N-1, this)</span>
      30: iload_3           <span class="fragment">// get arg3                   (stack: b, a, b, N-1, this)</span>
      31: iadd              <span class="fragment">// add 2 vars from the stack  (stack: a+b, b, N-1, this)</span>
      32: <span class="fragment highlight-red">invokevirtual</span> #40 <span class="fragment">// call fibonacciRec:(III)I   (stack: )</span>
      35: goto          39
      38: iload_2
      39: ireturn           <span class="fragment">// return arg2=b</span>
</code></pre>
				</section>
				<section>
					<h2>The secret life of invokevirtual</h2>
					<ul>
						<li>JVM takes control back from your code</li>
						<li>Resolves method by name</li>
						<li>Looks up method addr in vtable</li>
						<li>Creates stack frame</li>
						<li>Passes arguments</li>
						<li>Jumps back to your function code</li>
					</ul>
				</section>
				<section>
					<h2>Go deeper</h2>
          <pre><code data=trim data-noescape style="padding: 15px; max-height: 470px;" class="x86asm">....[Hottest Region 1].................................................
C2, level 4, ru.jugvrn.ScalaFibonacci::fibonacciRec, version 462 (62 bytes)

	0x00007f89f51fea20: mov    0x8(%rsi),%r10d     <span class="fragment">; note the real function address</span>
  0x00007f89f51fea24: shl    $0x3,%r10
  0x00007f89f51fea28: cmp    %r10,%rax
  0x00007f89f51fea2b: jne    0x00007f89f5045e20  ;   {runtime_call}
  0x00007f89f51fea31: xchg   %ax,%ax
  0x00007f89f51fea34: nopl   0x0(%rax,%rax,1)
  0x00007f89f51fea3c: xchg   %ax,%ax
    [Verified Entry Point]
  0x00007f89f51fea40: mov    %eax,-0x14000(%rsp)

		... skip ...

  0x00007f89f51fea73: callq  0x00007f89f5046020  <span class="fragment">; jump straight to JVM guts!</span>
	                                               ; OopMap{off=88}
                                                 ;*invokevirtual fibonacciRec
                                                 ;   {optimized virtual_call}
</code></pre>

				</section>
				<section>
					<h2>goto vs invokevirtual</h2>
					<p class="fragment">Goto: simple unconditional jump, one x86 instruction.</p>
					<p class="fragment">Invokevirtual: a lot of overhead happening under the hood.</p>
				</section>
				<section>
					<h2>Why is N=10 slower than N=20?</h2>
				</section>
				<section>
					<h2>N=10..20 tailrec performance</h2>
					<img src="images/tailrec10_20.png"/>
				</section>
				<section>
					live!
				</section>
				<section>
					<h2>Loop unroll</h2>
<pre><code data=trim data-noescape style="padding: 15px; max-height: 470px;" class="scala">  def fibonacciTCOUnroll(n: Int, a: Int, b: Int): Int = {
	  if (n == 0) {
			a
		} else if (n>16) {
      val f1 = a + b
      val f2 = f1 + b
      val f3 = f2 + f1
      val f4 = f3 + f2
      val f5 = f4 + f3
      // skip f6..f15
      val f16 = f13 + f14
      fibonacciTCOUnroll(n - 16, f15, f16)
		} else {
      fibonacciTCOUnroll(n - 1, b, a+b)
    }
  }
</code></pre>
				</section>
				<section>
					<h2>Recursive conclusion</h2>
					<ul>
						<li class="fragment">TCO is equal to loop</li>
						<li class="fragment">
							TCO is cool
							<ul>
								<li class="fragment">stop thinking with loops</li>
								<li class="fragment">stop computing fibonacci numbers</li>
								<li class="fragment">start writing readable recursive code</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					<h2>More about recursion</h2>
					<ul>
						<li><a href="http://shipilev.net/blog/2014/java-scala-divided-we-fail">A.Shipilёv, Scala vs Java: divided we fail</a></li>
						<li><a href=" http://shipilev.net/blog/2015/black-magic-method-dispatch">A.Shipilёv, The black magic of Java method dispatch</a></li>
						<li><a href="https://wiki.openjdk.java.net/dashboard.action">Oracle HotSpotInternals wiki</a></li>
					</ul>
				</section>
				<section data-background="images/slowpoke_collection.png">
					<h2><span style="background-color: white; padding: 10px">Collections</span></h2>
				</section>
				<section>
					<h2>Scala collections</h2>
					<ul>
						<li class="fragment">Easy way to do complex things</li>
						<li class="fragment">Cool things cannot be free: what's the overhead?</li>
					</ul>
				</section>
				<section>
					<h2>So many things to benchmark!</h2>
					<table>
						<tr>
							<td><img src="images/immutable_hierarchy.png" width="600px"/></td>
							<td><img src="images/mutable_hierarchy.png" width="600px"/></td>
						</tr>
					</table>
					<br/>
					<small>* Diagrams by Lokesh Jein: http://lkumarjain.blogspot.ru/2015/01/scala-collection-framework.html</small>
				</section>
				<section>
					<h2>The problem</h2>
					<ul>
						<li>Given a sequence of integer numbers</li>
						<li>Compute sum of their squares</li>
					</ul>
					<pre><code style=" font-size: 25px; line-height: 28px">
  in: [1, 2, 3]
  out: 1^2 + 2^2 + 3^2 = 14
					</code></pre>
				</section>
				<section>
					<h2>Old-school solution</h2>
					<pre><code data=trim data-noescape style="padding: 15px; max-height: 470px; font-size: 25px; line-height: 28px" class="scala">val array:Array[Int] = ???

@Benchmark
def baseline:Long = {
  var i = 0
  var sum = 0L
  while (i &lt; SIZE) {
	  sum += array(i) * array(i)
	  i += 1
	}
	sum
}
					</code></pre>
				</section>
				<section>
					<h2>FP-way</h2>
					<pre><code data=trim data-noescape style="padding: 15px; max-height: 470px; font-size: 25px; line-height: 28px" class="scala">val list:List[Int] = ???

@Benchmark
def foldList:Long = {
  list.foldLeft(0L)( (sum, next) => sum + next*next)
}	</code></pre>
				</section>
				<section>
					<h2>Quiz</h2>
					<p>Fold performance is ____________:</p>
					<ol>
						<li class="fragment">the same as loop</li>
						<li class="fragment">1.5x faster than loop</li>
						<li class="fragment">2x slower than loop</li>
						<li class="fragment"><span class="fragment highlight-green">7x slower than loop</span></li>
					</ol>
				</section>
				<section>
					<h2>Results</h2>
<pre><code  data=trim data-noescape style="padding: 15px; max-height: 470px; font-size: 25px; line-height: 28px" class="scala">  Benchmark   (SIZE)  Mode  Cnt      Score     Error  Units
  baseline       100  avgt  100     71.695 ±   0.524  ns/op
	baseline      1000  avgt  100    655.157 ±   2.248  ns/op
	baseline     10000  avgt  100   6457.211 ±  17.542  ns/op
	foldList       100  avgt  100    525.201 ±   5.903  ns/op
	foldList      1000  avgt  100   4880.612 ±  23.996  ns/op
	foldList     10000  avgt  100  47098.707 ±  67.334  ns/op
</code></pre>
					<ul>
						<li class="fragment">List != Array</li>
					</ul>
				</section>
				<section>
					<h2>JMH perf profiler</h2>
					Hardware performance counters to the rescue!
					<pre><code  data=trim data-noescape style="padding: 15px; max-height: 600px; font-size: 25px; line-height: 28px" class="scala">
  jmh:run -prof perf ru.jugvrn.ScalaListSquares.*
					</code></pre>
				</section>
				<section>
					<h2>Loop perf counters</h2>
<pre><code  data=trim data-noescape style="padding: 15px; max-height: 600px;" class="scala">
    9931.655974      task-clock (msec)         #    0.475 CPUs utilized
            932      context-switches          #    0.094 K/sec
             46      cpu-migrations            #    0.005 K/sec
            113      page-faults               #    0.011 K/sec
 25,735,792,483      cycles                    #    2.591 GHz
  9,267,196,267      stalled-cycles-frontend   #   36.01% frontend cycles idle
 66,270,818,101      instructions              #    2.58  insns per cycle
                                               #    0.14  stalled cycles per insn
<mark>  1,876,355,486      branches                  #  188.927 M/sec                  </mark>
      2,411,709      branch-misses             #    0.13% of all branches
 14,960,422,185      L1-dcache-loads           # 1506.337 M/sec
    492,379,799      L1-dcache-load-misses     #    3.29% of all L1-dcache hits
<mark>         62,251      LLC-loads                 #    0.006 M/sec                  </mark>
        399,928      L1-icache-load-misses     #    0.040 M/sec
  7,623,879,953      dTLB-loads                #  767.634 M/sec
         13,381      dTLB-load-misses          #    0.00% of all dTLB cache hits
         15,045      iTLB-loads                #    0.002 M/sec
          3,078      iTLB-load-misses          #   20.46% of all iTLB cache hits
    465,275,969      L1-dcache-prefetch-misses #   46.848 M/sec
</code></pre>
				</section>
				<section>
					<h2>List perf counters</h2>
<pre><code  data=trim data-noescape style="padding: 15px; max-height: 600px;" class="scala">
    9988.074145      task-clock (msec)         #    0.477 CPUs utilized
          2,230      context-switches          #    0.223 K/sec
            386      cpu-migrations            #    0.039 K/sec
            208      page-faults               #    0.021 K/sec
 24,191,015,522      cycles                    #    2.422 GHz
  5,917,795,429      stalled-cycles-frontend   #   24.46% frontend cycles idle
 78,929,694,484      instructions              #    3.26  insns per cycle
                                               #    0.07  stalled cycles per insn
 <mark>13,743,825,372      branches                  # 1376.024 M/sec                  </mark>
      2,356,556      branch-misses             #    0.02% of all branches
 26,411,359,322      L1-dcache-loads           # 2644.289 M/sec
  1,235,559,432      L1-dcache-load-misses     #    4.68% of all L1-dcache hits
<mark>    151,011,070      LLC-loads                 #   15.119 M/sec                  </mark>
      2,217,386      L1-icache-load-misses     #    0.222 M/sec
 24,726,569,508      dTLB-loads                # 2475.609 M/sec
        127,828      dTLB-load-misses          #    0.00% of all dTLB cache hits
        655,836      iTLB-loads                #    0.066 M/sec
        121,926      iTLB-load-misses          #   18.59% of all iTLB cache hits
  1,168,908,448      L1-dcache-prefetch-misses #  117.030 M/sec
</code></pre>
				</section>
				<section>
					<h2>List vs Array</h2>
					<img src="images/linkedlist.png" class="plain" width="700px"/>
				</section>
				<section>
					<h2>List vs Array</h2>
					<img src="images/array.png" class="plain" width="700px"/>
				</section>
			  <section>
<h2>Get rid of List!</h2>
<pre><code  data=trim data-noescape style="padding: 15px; max-height: 470px; font-size: 25px; line-height: 28px" class="scala">	val array:Array[Int] = ???

	@Benchmark
	def foldArray:Long = {
	  array.foldLeft(0L)( (sum, next) => sum + next*next)
	}
</code></pre>
         <img src="images/oh_yes.gif"/>
			  </section>
			<section>
       <h2>Results</h2>
<pre><code  data=trim data-noescape style="padding: 15px; max-height: 470px; font-size: 22px; line-height: 28px" class="scala">  Benchmark                    (SIZE)  Mode  Cnt      Score     Error  Units
	ScalaListSquares.baseline       100  avgt  100     71.695 ±   0.524  ns/op
	ScalaListSquares.baseline      1000  avgt  100    655.157 ±   2.248  ns/op
	ScalaListSquares.baseline     10000  avgt  100   6457.211 ±  17.542  ns/op
	ScalaListSquares.foldList       100  avgt  100    525.201 ±   5.903  ns/op
	ScalaListSquares.foldList      1000  avgt  100   4880.612 ±  23.996  ns/op
	ScalaListSquares.foldList     10000  avgt  100  47098.707 ±  67.334  ns/op
<mark>  ScalaListSquares.foldArray      100  avgt  100    470.091 ±   1.249  ns/op
  ScalaListSquares.foldArray     1000  avgt  100   6192.707 ±  12.944  ns/op
  ScalaListSquares.foldArray    10000  avgt  100  60182.719 ± 215.496  ns/op</mark>
</code></pre>
				<img src="images/wat.jpeg" height="200px" class="fragment"/>
			</section>
			<section>
				<h2>JMH Gc profiler</h2>
				<p>Lightweight low-overhead JMX-based GC profiling</p>
				<pre><code  data=trim data-noescape style="padding: 15px; max-height: 600px; font-size: 25px; line-height: 28px" class="scala">
jmh:run -prof gc ru.jugvrn.ScalaListSquares.foldArray
				</code></pre>
			</section>
			<section>
				<h2>GC profiling results</h2>
<pre><code  data=trim data-noescape style="padding: 15px; max-height: 470px; font-size: 22px; line-height: 28px" class="scala">foldArray                                       88434.926 ± 4464.565   ns/op
<mark>foldArray:·gc.alloc.rate                         1682.633 ±   81.873  MB/sec</mark>
foldArray:·gc.alloc.rate.norm                  155936.207 ±    0.497    B/op
foldArray:·gc.churn.PS_Eden_Space                1683.088 ±  130.033  MB/sec
foldArray:·gc.churn.PS_Eden_Space.norm         155924.367 ± 7109.615    B/op
foldArray:·gc.churn.PS_Survivor_Space               0.078 ±    0.068  MB/sec
foldArray:·gc.churn.PS_Survivor_Space.norm          7.232 ±    6.315    B/op
foldArray:·gc.count                               160.000             counts
foldArray:·gc.time                                 92.000                 ms
</code></pre>
				<p class="fragment">
        	<img src="images/wat.jpeg" height="200px"/>
					<img src="images/wat.jpeg" height="200px"/>
					<img src="images/wat.jpeg" height="200px"/>
				</p>
			</section>
			<section>
				<h2>Apples vs Oranges</h2>
				<pre><code data=trim data-noescape style="padding: 15px; max-height: 470px; font-size: 25px; line-height: 28px" class="scala">def baseline:Long = {
  var i = 0
  var sum = 0L <span class="fragment">// &lt;- primitive long</span>
  while (i &lt; SIZE) {
	  sum += array(i) * array(i)
	  i += 1
  }
  sum
}</code></pre>
				<pre><code data=trim data-noescape style="padding: 15px; max-height: 470px; font-size: 25px; line-height: 28px" class="scala">def foldArray:Long = {
  array.foldLeft(0L)( (sum, next) => sum + next*next) <span class="fragment">// &lt;- boxed Long</span>
}</code></pre>
				<p class="fragment">Creating a new object on each iteration</p>
			</section>
			<section>
				<h2>Scala collections are generic</h2>
				<ul>
					<li>def foldLeft[B](z: B)(op: (B, A) => B): B</li>
					<li>A &amp; B cannot be primitive<span style="color: red;">*</span></li>
					<li>No escape from boxing/unboxing ¯\_(ツ)_/¯</li>
				</ul>
			</section>
			<section>
				<h2>No escape?</h2>
				<p>It's time for 2.12!</p>
			</section>
			<section>
       <h2>Results with 2.12</h2>
<pre><code  data=trim data-noescape style="padding: 15px; max-height: 470px; font-size: 22px; line-height: 28px" class="scala">  Benchmark                    (SIZE)  Mode  Cnt      Score     Error  Units
	ScalaListSquares.baseline       100  avgt  100     71.695 ±   0.524  ns/op
	ScalaListSquares.baseline      1000  avgt  100    655.157 ±   2.248  ns/op
	ScalaListSquares.baseline     10000  avgt  100   6457.211 ±  17.542  ns/op
  ScalaListSquares.foldArray      100  avgt  100    470.091 ±   1.249  ns/op
  ScalaListSquares.foldArray     1000  avgt  100   6192.707 ±  12.944  ns/op
  ScalaListSquares.foldArray    10000  avgt  100  60182.719 ± 215.496  ns/op
<mark>  ScalaListSquares.foldArray12    100  avgt  100    482.969 ±   1.975  ns/op
	ScalaListSquares.foldArray12   1000  avgt  100   7114.175 ±  19.649  ns/op
	ScalaListSquares.foldArray12  10000  avgt  100  71247.456 ± 311.178  ns/op</mark>
</code></pre>
				<img src="images/jaw_drop.gif" class="fragment" height="200px"/>
			</section>
			<section>
				<h2>Sugar-free scala</h2>
				scalac -print Foo.scala
			</section>
			<section>
				<h2>2.11 desugared</h2>
<pre><code  data=trim data-noescape style="padding: 15px; max-height: 550px;" class="scala">def foldArray(): Long = scala.Long.unbox(
  scala.this.Predef.intArrayOps(ScalaListSquares.this.array())
	  .foldLeft(
		  scala.Long.box(0L),
			{ (new <$anon: Function2>(ScalaListSquares.this): Function2) }
		)
	);
final class anonfun$foldArray$1 extends scala.runtime.AbstractFunction2$mcJJI$sp with Serializable {
  final def apply(part: Long, next: Int): Long =
	  anonfun$foldArray$1.this.apply$mcJJI$sp(part, next);
  def apply$mcJJI$sp(part: Long, next: Int): Long =
	  part.+(next.*(next));
  final def apply(v1: Object, v2: Object): Object =
	  scala.Long.box(                   // here it is!
		  anonfun$foldArray$1.this.apply(
			  scala.Long.unbox(v1),         // again!
				scala.Int.unbox(v2)           // and again!
			)
		);
  def &lt;init&gt;($outer: ru.jugvrn.ScalaListSquares): <$anon: Function2> =
    anonfun$foldArray$1.super.<init>();
}</code></pre>
			</section>
			<section>
				<h2>2.12 desugared</h2>
<pre><code  data=trim data-noescape style="padding: 15px; max-height: 550px;" class="scala">
def foldArray(): Long = scala.Long.unbox(
  new collection.mutable.ArrayOps$ofInt(
	  scala.Predef.intArrayOps(ScalaListSquares.this.array())
	).foldLeft(
	  scala.Long.box(0L),
		{ ((part: Long, next: Int) =>
			ScalaListSquares.this.$anonfun$foldArray$1(part, next)) }
	)
);

final def $anonfun$foldArray$1(part: Long, next: Int): Long =
  part.+(next.*(next)); // Where is box/unbox?

</code></pre>
			</section>
			<section>
				<h2>Lambdas in 2.11/2.12</h2>
				<table>
					<tr>
						<td class="fragment">
							<p>2.11, java7:</p>
							<ul>
								<li>FunctionN class wrapper</li>
								<li>compile-time linking</li>
								<li>invokevirtual</li>
							</ul>
						</td>
						<td class="fragment">
							<p>2.12, java8:</p>
							<ul>
								<li>lambda as a method</li>
								<li>run-time linking</li>
								<li>invokedynamic</li>
								<li>JFunctionN functional interface</li>
							</ul>
						</td>
					</tr>
				</table>
			</section>
			<section>
				<h2>JFunction2</h2>
<pre><code  data=trim data-noescape style="padding: 15px; max-height: 550px; font-size: 25px; line-height: 28px" class="scala">package scala.runtime.java8;

@FunctionalInterface
public interface JFunction2$mcDII$sp
    extends scala.Function2, java.io.Serializable {
  double apply$mcDII$sp(int v1, int v2);

  default Object apply(Object v1, Object v2) {
		return scala.runtime.BoxesRunTime.boxToDouble( // found it!
		  apply$mcDII$sp(
			  scala.runtime.BoxesRunTime.unboxToInt(v1),
				scala.runtime.BoxesRunTime.unboxToInt(v2)
			)
		);
	}
}</code></pre>
			</section>
			<section>
				<h2>2.11 vs 2.12</h2>
				<p>Why foldArray@2.12 is slower than foldArray@2.11?</p>
				<img src="images/why.gif"/>
			</section>
			<section>
				<h2>2.11: hottest methods</h2>
<pre><code  data=trim data-noescape style="padding: 15px; max-height: 550px; font-size: 23px; line-height: 28px" class="scala">....[Hottest Methods (after inlining)]...................................
96.29%   97.82%     C2, level 4  r.j.g.ScalaListSquares_foldArray_jmhTest
 0.37%    0.19%       libjvm.so  StringTable::unlink_or_oops_do
 0.34%    0.08%       libjvm.so  SpinPause
 0.16%    0.04%       libjvm.so  ParallelTaskTerminator::offer_termination
 0.14%    0.01%       libjvm.so  PSScavengeKlassClosure::do_klass
 0.09%    0.05%    libc-2.23.so  vfprintf

</code></pre>
			</section>
			<section>
				<h2>2.12: hottest methods</h2>
<pre><code  data=trim data-noescape style="padding: 15px; max-height: 550px; font-size: 23px; line-height: 28px" class="scala">....[Hottest Methods (after inlining)]...................................
89.76%   91.56%     C2, level 4  r.j.g.ScalaListSquares_foldArray_jmhTest
 4.71%    4.70%     C2, level 4  s.c.m.ArrayOps$ofLong::foldLeft
 0.44%    0.45%     C2, level 4  r.j.ScalaListSquares::foldArray
 0.26%    0.01%       libjvm.so  SpinPause
 0.20%    0.29%       libjvm.so  StringTable::unlink_or_oops_do
 0.17%    0.10%       libjvm.so  fileStream::write
 0.14%    0.13%    libc-2.23.so  vfprintf
</code></pre>
			</section>

			<section>
				<h2>Scala collections</h2>
				<ul>
					<li class="fragment">Be aware of boxing</li>
					<li class="fragment">Even Array can cause boxing</li>
					<li class="fragment">Alternative collections: debox, abc</li>
				</ul>
			</section>
			<section>
				<h2>The end</h2>
				<p class="fragment">Scala can be slow:</p>
				<ul>
					<li class="fragment">easy to write beautiful, but slow code</li>
					<li class="fragment">collections + primitives = pain</li>
					<li class="fragment">JVM doesn't like scalac bytecode</li>
				</ul>
				<br/><br/>
				<p class="fragment">Scala can be fast:</p>
				<ul>
					<li class="fragment">Know your roots: beautiful code can be fast</li>
					<li class="fragment">Scala 2.12 is more JVM-friendly</li>
				</ul>
			</section>
			<section>
				<h2>Materials</h2>
				<p>Benchmarks: <a href="https://github.com/shuttie/scala-perf-talk">github.com/shuttie/scala-perf-talk</a></p>
				<p>Slides: <a href="http://dfdx.me/talks/scala_is_slow_eng">dfdx.me/talks/scala_is_slow</a></p>
				<p>Me: <a href="https://twitter.com/public_void_grv">@public_void_grv</a>, <a href="mailto:grv@dfdx.me">grv@dfdx.me</a></p>
			</section>
			<section>
				<h2>Questions</h2>
				<img src="images/head-boom.gif"/>
			</section>

		</div>

		<footer>
			<img src="images/sponsors.png" height="40px"/>
		</footer>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,
				progress: true,
				slideNumber: true,
				width: 1200,
				height: 700,
				transition: 'none',
				transitionSpeen: 'fast',

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); hljs.configure({tabReplace: '  '}); } }
				]
			});
		</script>
	</body>
</html>
